"""
напишите функцию, которая принимает на вход число кубиков, число сторон на кубике и исследуемый номер, а возвращает вероятность получения заданного значения. Результат должен возвращаться с точностью в четыре цифры после запятой - ±0.0001. Например, если вы бросили 2 шестигранных кубика, вероятность что выпадет 3 составляет 2/36 или 5,56% в процентном соотношении, соответственно ваша функция должна вернуть число, записанное как ≈0.0556. В дроби 2/36 числитель, это количество возможных вариаций получения числа 3 на двух кубиках (1;2 или 2;1), а знаменатель, это количество возможных комбинаций для 2-х шистигранных кубиков (6**2)
 Для каждого теста, предполагается, что все кости одинаковы и пронумерованы от 1 и до числа сторон, заданных входными данными включительно. Таким образом, 4-сторонний кубик (D4) будет иметь равные шансы на выпадения чисел 1, 2, 3 или 4. И эти шансы можно оценить как 1/4. А 20-сторонний кубик (D20) будет иметь равные шансы на выпадение любого числа от 1 до 20, которые можно оценить как 1/20.

Советы: Будьте осторожны, если вы захотите решить эту задачу путем перебора всех возможных вариаций - вам возможно придется очень долго ждать! Например для входных данных (10, 10, 50) - время ожидания может достигать нескольких десятков минут! Используйте принцип динамического программирования.

На входе: Три аргумента. Количество кубиков, количество сторон на кубике и исследуемое значение как целые числа.

На выходе: Вероятность получения заданного значения за один бросок игральных костей, как число с плавающей запятой.
"""


from math import factorial
from itertools import combinations_with_replacement, groupby
from functools import reduce


def probability(dice_number, sides, target):
    counter = 0
    for i in combinations_with_replacement(range(1, sides + 1), dice_number):
        if sum(i) == target:
            itemCount = [len([k for k in j]) for _, j in groupby(i)]
            counter += factorial(len(i)) * 1.0 / reduce(lambda x, y: x * y,
                                                        map(factorial,
                                                            itemCount))
    return round(counter * 1.0 / (sides ** dice_number), 4)


print(probability(2, 6, 3) == 0.0556)
print(probability(2, 6, 4) == 0.0833)
print(probability(2, 6, 7) == 0.1667)
print(probability(2, 3, 5) == 0.2222)
print(probability(2, 3, 7) == 0)
print(probability(3, 6, 7) == 0.0694)
print(probability(10, 10, 50) == 0.0375)
print(probability(3, 6, 10) == 0.1250)
print(probability(2, 6, 2) == 0.0278)
print(probability(3, 6, 3) == 0.0046)
print(probability(3, 6, 4) == 0.0139)
print(probability(3, 6, 5) == 0.0278)
print(probability(3, 6, 6) == 0.0463)
print(probability(3, 6, 16) == 0.0278)
print(probability(2, 6, 10) == 0.0833)
print(probability(2, 6, 8) == 0.1389)

